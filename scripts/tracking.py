import argparse
from operator import itemgetter
from pathlib import Path
import json
import typing
from functools import partial

import numpy as np
import pandas as pd
from tqdm import tqdm

BOX = typing.Union[
    np.ndarray,
    typing.List[typing.Union[int, float]],
    typing.Tuple[typing.Union[int, float], ...],
]


def center(bbox: BOX) \
        -> typing.Tuple[float, float]:
    x1, y1, x2, y2 = bbox
    return (x2 - x1) / 2 + x1, (y2 - y1) / 2 + y1


def distance(bbox1: BOX, bbox2: BOX) \
        -> float:
    (x1, y1), (x2, y2) = center(bbox1), center(bbox2)
    return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** .5


def size(bbox: BOX) \
        -> float:
    x1, y1, x2, y2 = bbox
    return ((x2 - x1) * (y2 - y1)) ** .5


def blend(bbox1: BOX, bbox2: BOX, ratio: float) \
        -> BOX:
    def blend_(x1_: float, x2_: float, ratio_: float) \
            -> float:
        return (x2_ - x1_) * ratio_ + x1_

    x11, y11, x12, y12 = bbox1
    w, h = x12 - x11, y12 - y11
    (x1, y1), (x2, y2) = center(bbox1), center(bbox2)
    x, y = blend_(x1, x2, ratio), blend_(y1, y2, ratio)

    return list(map(int, (x - w / 2, y - h / 2, x + w / 2, y + h / 2)))


def iou(bbox1: BOX, bbox2: BOX) \
        -> float:
    (x0_1, y0_1, x1_1, y1_1) = map(float, bbox1)
    (x0_2, y0_2, x1_2, y1_2) = map(float, bbox2)

    overlap_x0 = max(x0_1, x0_2)
    overlap_y0 = max(y0_1, y0_2)
    overlap_x1 = min(x1_1, x1_2)
    overlap_y1 = min(y1_1, y1_2)

    if overlap_x1 - overlap_x0 <= 0 or overlap_y1 - overlap_y0 <= 0:
        return 0

    size_1 = (x1_1 - x0_1) * (y1_1 - y0_1)
    size_2 = (x1_2 - x0_2) * (y1_2 - y0_2)
    size_intersection = (overlap_x1 - overlap_x0) * (overlap_y1 - overlap_y0)
    size_union = size_1 + size_2 - size_intersection

    return size_intersection / size_union


def get_best_match(bbox: BOX, bboxes: typing.Union[np.ndarray, BOX]) \
        -> typing.Tuple[int, float, BOX]:
    iou_array = np.array(list(map(
        partial(iou, bbox),
        bboxes,
    )))

    best_idx = iou_array.argmax()
    best_match = bboxes[best_idx]
    return best_idx, iou_array[best_idx], best_match


def track_iou(
    detections,
    sigma_l: float = .05, sigma_h: float = .75,
    sigma_iou: float = .35, t_min: int = 10,
):
    """
    Simple IOU based tracker.
    See "High-Speed Tracking-by-Detection Without Using Image Information by E. Bochinski, V. Eiselein, T. Sikora" for
    more information.
    Args:
         detections (list): list of detections per frame, usually generated by util.load_mot
         sigma_l (float): low detection threshold.
         sigma_h (float): high detection threshold.
         sigma_iou (float): IOU threshold.
         t_min (float): minimum track length in frames.
    Returns:
        list: list of tracks.
    """

    tracks_active = []
    tracks_finished = []

    for frame_num, detections_frame in enumerate(tqdm(detections), start=1):
        # apply low threshold to detections
        dets = detections_frame.copy()

        updated_tracks = []
        missing_tracks = []
        for tid, track in enumerate(tracks_active):
            if len(dets) <= 0:
                best_idx, best_iou = 0, 0
            else:
                best_idx, best_iou, best_box = get_best_match(
                    track['bboxes'][-1],
                    list(map(itemgetter('bbox'), dets)),
                )

                check_idx, check_iou, check_box = get_best_match(
                    best_box,
                    [track['bboxes'][-1] for track in tracks_active]
                )
                if best_iou < check_iou and not track['skip']:
                    track['skip'] = True
                    tracks_active.append(track)
                    continue

            if best_iou > 0.:
                if track['lost'][-1] != -1:
                    track['lost'].append(-1)
                track['bboxes'].append(best_box)
                updated_tracks.append(track)
                del dets[best_idx]

            else:
                if track['lost'][-1] == -1 or track['lost'][-1] + t_min >= frame_num:
                    if track['lost'][-1] == -1:
                        track['lost'][-1] = frame_num

                    best_idx, best_iou, best_box = get_best_match(
                        track['bboxes'][-1],
                        list(map(itemgetter('bbox'), detections_frame)),
                    )

                    if best_iou <= 0.:
                        best_box = track['bboxes'][-1]
                    else:
                        best_box = blend(track['bboxes'][-1], best_box, best_iou)

                    track['bboxes'].append(best_box)
                    missing_tracks.append(track)

                elif track['lost'][-1] + t_min <= frame_num:
                    with open('dets.json', 'w') as f:
                        json.dump(dets, f)
                    with open('test.json', 'w') as f:
                        json.dump(track, f)
                    if track['start_frame'] + 1 != track['lost'][-1]:
                        tracks_finished.append(track)
                else:
                    raise RuntimeError("Not implemented error -1")

        for det in dets:
            if len(missing_tracks) <= 0:
                break

            dists = np.array(list(map(
                partial(distance, det['bbox']),
                [track['bboxes'][-1] for track in missing_tracks],
            )))
            best_idx = dists.argmin()
            if det['score'] > sigma_l and dists[best_idx] < size(det['bbox']) * 3:
                missing_tracks[best_idx]['bboxes'][-1] = det['bbox']
                missing_tracks[best_idx]['lost'].append(-1)
                updated_tracks.append(missing_tracks[best_idx])
                del missing_tracks[best_idx]

        # create new tracks
        new_tracks = [{
            'bboxes': [det['bbox']],
            'max_score': det['score'],
            'start_frame': frame_num,
            'lost': [-1],
            'skip': False,
        } for det in dets]
        tracks_active = updated_tracks + missing_tracks + new_tracks
        for track in tracks_active:
            track['skip'] = False

    # finish all remaining active tracks
    tracks_finished += [
        track for track in tracks_active
        if track['max_score'] >= sigma_h and len(track['bboxes']) >= t_min
    ]

    return tracks_finished


def main(args: argparse.Namespace):
    annotations_path = Path(args.annotations)
    outputs_path = Path(args.outputs)
    outputs_path.mkdir(exist_ok=True, parents=True)

    for segment in tqdm(sorted(annotations_path.iterdir())):
        out_path = outputs_path.joinpath(segment.stem)
        out_path.mkdir(exist_ok=True, parents=True)

        annotations = segment.glob(f'{segment.stem}_*.csv')
        annotation_ctx = annotations_path.joinpath(segment.stem, 'detections.json')

        if annotation_ctx.exists() and not args.override:
            with annotation_ctx.open() as f:
                detections = json.load(f)
        else:
            detections = []
            for annotation in annotations:
                df = pd.read_csv(annotation, header=None)

                detection = []
                for *points, acc, bg in df.values:
                    if not bg:
                        x1, y1, x2, y2 = map(int, points)
                        detection.append({
                            'bbox': (x1, y1, x2, y2),
                            'score': acc,
                            'class': 1
                        })

                detections.append(detection)
            with annotation_ctx.open('w') as f:
                json.dump(detections, f)

        tracks = track_iou(detections)        
        with out_path.joinpath('tracking.json').open('w') as f:
            json.dump(tracks, f)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--annotations', type=str, default='E:\\datasets\\fly\\meta\\annotations')
    parser.add_argument('--outputs', type=str, default='E:\\datasets\\fly\\meta\\images-raw')

    parser.add_argument('--override', action='store_true', default=False)

    main(parser.parse_args())
